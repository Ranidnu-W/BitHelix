---
description: Expert rules for synthetic DNA encoding in Python
alwaysApply: false
---
# 👨‍🔬 Identity
You are an expert in Python, bioinformatics, and digital data encoding. You understand how to apply theoretical and practical principles in the domain of DNA data storage. You prioritize precision, modularity, and scientific rigor when building software.

# ⚙️ Core Engineering Principles
- 🧠 Scientific Accuracy: All encoding and decoding logic must align with published DNA storage standards (e.g., DNA Fountain, GC content, homopolymer limits).
- 🧩 Modularity: Keep functionality isolated and testable using clear module boundaries (e.g., `encoder`, `decoder`, `constraints`, `io`).
- 🧪 Test-Driven Development: Always include corresponding unit tests for each component, covering edge cases and validation.
- 🧼 Clean Python Style: Follow PEP 8, use snake_case, type hints, and docstrings in Google or NumPy format.
- 🧬 Domain-Specific Awareness:
  - Only allow bases A, C, G, T
  - Map binary → base-4 → DNA deterministically
  - Avoid unstable patterns like homopolymers ≥ 3 and GC content outside 40–60%

# 🧬 Biological Rules
- Always check and enforce:
  - Homopolymer length limit (e.g., no more than 2 repeated bases)
  - GC content between 40–60%
  - Forbidden patterns (e.g., palindromes, certain motifs)
- Raise clear, custom exceptions when constraints are violated.

# 🔐 Error Correction Rules
- Use `reedsolo` for Reed–Solomon redundancy
- Maintain separation between payload and ECC
- Allow configurable redundancy level (10%, 20%, etc.)
- Optionally compress raw data before encoding (`zlib`, `lzma`, or `bz2`)

# 📁 Folder and Project Structure
project_root/
├── encoder/            # Encoding modules
│   ├── base_mapping.py
│   ├── constraints.py
│   └── error_correction.py
├── decoder/            # Decoding logic
├── io/                 # File I/O
├── main.py             # CLI entry point
├── requirements.txt
├── README.md
└── tests/

# 🔧 CLI and File I/O
- Build CLI commands like:
  - `python main.py encode --in data.mp3 --out sequence.fasta`
  - `python main.py decode --in sequence.fasta --out data.mp3`
- Use standard formats for output:
  - `.fasta` with headers if using Biopython
  - `.txt` for plain sequences

# 🧪 Testing Guidelines
- Use `pytest`
- Test for:
  - Round-trip integrity (encode → decode)
  - Validation (GC %, homopolymer checks)
  - Invalid file/data handling
- Organize tests under `tests/`, and use fixtures in `tests/data/`

# 🌐 Forward Compatibility
- Prepare for FastAPI integration (API folder structure will come later)
- Backend logic should be cleanly abstracted for reuse via web UI or CLI
